{"version":3,"sources":["js/ConnectFour.js","js/main.js"],"names":["ConnectFour","selector","gameOver","playerTurn","cellOwners","lastMove","updateTime","colourRed","colourYellow","colourBlue","colourBlank","rows","columns","aspectRatio","connect","canvas","document","getElementById","ctx","getContext","width","scrollWidth","height","scrollHeight","cellWidth","cellHeight","radius","radiusSemi","initialise","addEventListener","click","bind","mouseMove","window","resizeGame","windowWidth","innerWidth","windowHeight","innerHeight","drawGrid","rowsArray","i","j","push","event","cell","getCell","offsetX","offsetY","drawCell","Date","now","semiCircle","centerX","centerY","fillStyle","beginPath","arc","Math","PI","fill","x","y","trunc","checkCell","roundRect","stroke","tl","tr","br","bl","defaultRadius","side","moveTo","lineTo","quadraticCurveTo","closePath","console","log","connectFour"],"mappings":";;;AAmPK,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA,EAnPQA,IAAAA,EAmPR,WAlPWC,SAAAA,EAAAA,GAAU,EAAA,KAAA,GAEbC,KAAAA,UAAW,EACXC,KAAAA,WAAa,EACbC,KAAAA,WAAa,GACbC,KAAAA,SAAW,EACXC,KAAAA,WAAa,IAGbC,KAAAA,UAAY,mBACZC,KAAAA,aAAe,oBACfC,KAAAA,WAAa,oBACbC,KAAAA,YAAc,qBAGdC,KAAAA,KAAO,EACPC,KAAAA,QAAU,EACVC,KAAAA,YAAc,KAAKD,QAAU,KAAKD,KAClCG,KAAAA,QAAU,EAEVC,KAAAA,OAASC,SAASC,eAAehB,GACjCiB,KAAAA,IAAM,KAAKH,OAAOI,WAAW,MAE7BC,KAAAA,MAAQ,KAAKL,OAAOM,YACpBC,KAAAA,OAAS,KAAKP,OAAOQ,aACrBR,KAAAA,OAAOK,MAAQ,KAAKA,MACpBL,KAAAA,OAAOO,OAAS,KAAKA,OAErBE,KAAAA,UAAY,KAAKJ,MAAQ,KAAKR,QAC9Ba,KAAAA,WAAa,KAAKH,OAAS,KAAKX,KAChCe,KAAAA,OAAS,KAAKF,UAAY,IAC1BG,KAAAA,WAAa,KAAKH,UAAY,IAE9BI,KAAAA,aAGAb,KAAAA,OAAOc,iBAAiB,QAAS,KAAKC,MAAMC,KAAK,OACjDhB,KAAAA,OAAOc,iBAAiB,YAAa,KAAKG,UAAUD,KAAK,OAC9DE,OAAOJ,iBAAiB,SAAU,KAAKK,WAAWH,KAAK,OAAO,GAC9DE,OAAOJ,iBAAiB,oBAAqB,KAAKK,WAAWH,KAAK,OAAO,GA2M5E,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,aAxMY,MAAA,WACLI,IAAAA,EAAcF,OAAOG,WACrBC,EAAeJ,OAAOK,YACFH,EAAcE,EAEd,KAAKxB,aACpBE,KAAAA,OAAOO,OAASe,EAChBtB,KAAAA,OAAOK,MAAQ,KAAKP,YAAcwB,IAGlCtB,KAAAA,OAAOK,MAAQe,EACfpB,KAAAA,OAAOO,OAASa,EAAc,KAAKtB,aAIvCO,KAAAA,MAAQ,KAAKL,OAAOM,YACpBC,KAAAA,OAAS,KAAKP,OAAOQ,aACrBR,KAAAA,OAAOK,MAAQ,KAAKA,MACpBL,KAAAA,OAAOO,OAAS,KAAKA,OAErBE,KAAAA,UAAY,KAAKJ,MAAQ,KAAKR,QAC9Ba,KAAAA,WAAa,KAAKH,OAAS,KAAKX,KAChCe,KAAAA,OAAS,KAAKF,UAAY,IAC1BG,KAAAA,WAAa,KAAKH,UAAY,IAG9Be,KAAAA,aA8KR,CAAA,IAAA,aA3KY,MAAA,WAGJ,IADDC,IAAAA,EAAY,GACPC,EAAI,EAAGA,EAAI,KAAK7B,QAAS6B,IAAK,CAC9B,IAAA,IAAIC,EAAI,EAAGA,EAAI,KAAK/B,KAAM+B,IAC3BF,EAAUG,KAAK,MAEdvC,KAAAA,WAAWuC,KAAKH,GACrBA,EAAY,GAIXN,KAAAA,eA+JR,CAAA,IAAA,QA3JKU,MAAAA,SAAAA,GAGEC,IAAAA,EAAO,KAAKC,QAAQF,EAAMG,QAASH,EAAMI,UAE7B,GAAZH,EAAK,KAIAzC,KAAAA,WAAWyC,EAAK,IAAIA,EAAK,IAAM,KAAK1C,WAGpCoC,KAAAA,WAGApC,KAAAA,YAAc,EAGnB0C,EAAO,KAAKC,QAAQF,EAAMG,QAASH,EAAMI,SACpCC,KAAAA,SAASJ,GAAM,MAwI3B,CAAA,IAAA,YApISD,MAAAA,SAAAA,GAEFM,GAAAA,KAAKC,MAAQ,KAAK9C,SAAW,KAAKC,WAAY,CAE1CuC,IAAAA,EAAO,KAAKC,QAAQF,EAAMG,QAASH,EAAMI,UAG7B,GAAZH,EAAK,GACAN,KAAAA,YAIAA,KAAAA,WACAU,KAAAA,SAASJ,GAAM,IAInBxC,KAAAA,SAAW6C,KAAKC,SAmH5B,CAAA,IAAA,WA/GQN,MAAAA,SAAAA,GAAMO,IAAAA,EAAa,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GACpBC,EAAWR,EAAK,GAAK,KAAKrB,UAAc,KAAKA,UAAY,EACzD8B,EAAWT,EAAK,GAAK,KAAKpB,WAAe,KAAKA,WAAa,EAGxC,GAAnB,KAAKtB,WAEAe,KAAAA,IAAIqC,UAAY,KAAKhD,UAGrBW,KAAAA,IAAIqC,UAAY,KAAK/C,aAIzBU,KAAAA,IAAIsC,YACJtC,KAAAA,IAAIuC,IAAIJ,EAASC,EAAS,KAAK5B,OAAQ,EAAG,EAAIgC,KAAKC,IACnDzC,KAAAA,IAAI0C,OAGLR,IACKlC,KAAAA,IAAIqC,UAAY,KAAK7C,YACrBQ,KAAAA,IAAIsC,YACJtC,KAAAA,IAAIuC,IAAIJ,EAASC,EAAS,KAAK3B,WAAY,EAAG,EAAI+B,KAAKC,IACvDzC,KAAAA,IAAI0C,UAwFhB,CAAA,IAAA,YAnFSC,MAAAA,SAAAA,EAAGC,GAGF,OAFHD,GAAK,KAAKzC,OAAOyC,IACjBC,GAAK,KAAKxC,QAAQwC,IACf,CAACJ,KAAKK,MAAMF,EAAI,KAAKrC,WAAYkC,KAAKK,MAAMD,EAAI,KAAKrC,eAgF/D,CAAA,IAAA,UA7EOoC,MAAAA,SAAAA,EAAGC,GAKF,IAHDjB,IAAAA,EAAO,KAAKmB,UAAUH,EAAGC,GAGpBrB,EAAI,EAAGA,EAAI,KAAK9B,KAAM8B,IACvB,GAAgC,OAAhC,KAAKrC,WAAWyC,EAAK,IAAIJ,GAClB,MAAA,CAACI,EAAK,GAAIJ,EAAI,GAGtB,MAAA,CAACI,EAAK,GAAI,KAAKlC,KAAO,KAmEhC,CAAA,IAAA,WAhEU,MAAA,WAEFO,KAAAA,IAAIqC,UAAY,KAAK9C,WACrBwD,KAAAA,UAAU,KAAK/C,IAAK,EAAG,EAAG,KAAKE,MAAO,KAAKE,OAAQ,KAAKI,QAAQ,GAAM,GAKtE,IAFDmC,IAAAA,EAAI,KAAKrC,UAAY,EACrBsC,EAAI,KAAKrC,WAAa,EACjBgB,EAAI,EAAGA,EAAI,KAAK7B,QAAS6B,IAAK,CAC9B,IAAA,IAAIC,EAAI,EAAGA,EAAI,KAAK/B,KAAM+B,IACE,GAAzB,KAAKtC,WAAWqC,GAAGC,GACdxB,KAAAA,IAAIqC,UAAY,KAAKhD,UACM,GAAzB,KAAKH,WAAWqC,GAAGC,GACrBxB,KAAAA,IAAIqC,UAAY,KAAK/C,aAErBU,KAAAA,IAAIqC,UAAY,KAAK7C,YAGzBQ,KAAAA,IAAIsC,YACJtC,KAAAA,IAAIuC,IAAII,EAAGC,EAAG,KAAKpC,OAAQ,EAAG,EAAIgC,KAAKC,IACvCzC,KAAAA,IAAI0C,OAETE,GAAQ,KAAKrC,WAEjBqC,EAAI,KAAKrC,WAAa,EACtBoC,GAAQ,KAAKrC,aAuCpB,CAAA,IAAA,YAjCSN,MAAAA,SAAAA,EAAK2C,EAAGC,EAAG1C,EAAOE,EAAQI,EAAQkC,EAAMM,GAO1C,QANkB,IAAXA,IACPA,GAAS,QAES,IAAXxC,IACPA,EAAS,GAES,iBAAXA,EACPA,EAAS,CAAEyC,GAAIzC,EAAQ0C,GAAI1C,EAAQ2C,GAAI3C,EAAQ4C,GAAI5C,OAChD,CACC6C,IAAAA,EAAgB,CAAEJ,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAC1C,IAAA,IAAIE,KAAQD,EACb7C,EAAO8C,GAAQ9C,EAAO8C,IAASD,EAAcC,GAGrDtD,EAAIsC,YACJtC,EAAIuD,OAAOZ,EAAInC,EAAOyC,GAAIL,GAC1B5C,EAAIwD,OAAOb,EAAIzC,EAAQM,EAAO0C,GAAIN,GAClC5C,EAAIyD,iBAAiBd,EAAIzC,EAAO0C,EAAGD,EAAIzC,EAAO0C,EAAIpC,EAAO0C,IACzDlD,EAAIwD,OAAOb,EAAIzC,EAAO0C,EAAIxC,EAASI,EAAO2C,IAC1CnD,EAAIyD,iBAAiBd,EAAIzC,EAAO0C,EAAIxC,EAAQuC,EAAIzC,EAAQM,EAAO2C,GAAIP,EAAIxC,GACvEJ,EAAIwD,OAAOb,EAAInC,EAAO4C,GAAIR,EAAIxC,GAC9BJ,EAAIyD,iBAAiBd,EAAGC,EAAIxC,EAAQuC,EAAGC,EAAIxC,EAASI,EAAO4C,IAC3DpD,EAAIwD,OAAOb,EAAGC,EAAIpC,EAAOyC,IACzBjD,EAAIyD,iBAAiBd,EAAGC,EAAGD,EAAInC,EAAOyC,GAAIL,GAC1C5C,EAAI0D,YACAhB,GACA1C,EAAI0C,OAEJM,GACAhD,EAAIgD,aAGX,EAAA,GAAA,QAAA,YAAA;;AC7OL,aAJA,QAAA,qBACA,IAAA,EAAA,QAAA,oBAHAW,QAAQC,IAAI,WAMZ,IAAMC,EAAc,IAAI/E,EAAJ,YAAgB","file":"main.39bdf027.js","sourceRoot":"..\\src","sourcesContent":["export class ConnectFour {\r\n    constructor(selector) {\r\n        // Game variables\r\n        this.gameOver = false;\r\n        this.playerTurn = 0;                // player 0 is red, player 1 is yellow\r\n        this.cellOwners = [];               // 2d array. Columns then rows\r\n        this.lastMove = 0;                  // user to keep track of refresh rate\r\n        this.updateTime = 100;              // How often mouseMovement can update in ms\r\n\r\n        // Colours\r\n        this.colourRed = 'rgb(240, 41, 41)';\r\n        this.colourYellow = 'rgb(240, 232, 10)';\r\n        this.colourBlue = 'rgb(44, 173, 242)';\r\n        this.colourBlank = 'rgb(255, 255, 255)';\r\n\r\n        // Drawing variables\r\n        this.rows = 6;\r\n        this.columns = 7;\r\n        this.aspectRatio = this.columns / this.rows;\r\n        this.connect = 4;                                       // number of pucks needed to algin to win\r\n\r\n        this.canvas = document.getElementById(selector);        // the canvas element\r\n        this.ctx = this.canvas.getContext('2d');                // the canvas context\r\n\r\n        this.width = this.canvas.scrollWidth;                   // setting the canvas elements width to a variable\r\n        this.height = this.canvas.scrollHeight;                 // setting the canvas elements height to a variable\r\n        this.canvas.width = this.width;                         // set canvas width to the same as the canvas element\r\n        this.canvas.height = this.height;                       // set canvas height to the same as the canvas element\r\n\r\n        this.cellWidth = this.width / this.columns;\r\n        this.cellHeight = this.height / this.rows;\r\n        this.radius = this.cellWidth / 2.6;                     // sets raius for full circle that scales with canvas\r\n        this.radiusSemi = this.cellWidth / 3.6;                 // sets radius for circle outline that scales with canvas\r\n\r\n        this.initialise();\r\n\r\n        // Event listeners\r\n        this.canvas.addEventListener('click', this.click.bind(this));\r\n        this.canvas.addEventListener('mousemove', this.mouseMove.bind(this));\r\n        window.addEventListener('resize', this.resizeGame.bind(this), false);\r\n        window.addEventListener('orientationchange', this.resizeGame.bind(this), false);\r\n    }\r\n\r\n    resizeGame() {\r\n        let windowWidth = window.innerWidth;\r\n        let windowHeight = window.innerHeight;\r\n        let windowAspectRatio = windowWidth / windowHeight;\r\n\r\n        if (windowAspectRatio > this.aspectRatio) {\r\n            this.canvas.height = windowHeight;\r\n            this.canvas.width = this.aspectRatio * windowHeight;\r\n\r\n        } else {\r\n            this.canvas.width = windowWidth;\r\n            this.canvas.height = windowWidth / this.aspectRatio;\r\n        }\r\n\r\n        // reset all drawing variables\r\n        this.width = this.canvas.scrollWidth;\r\n        this.height = this.canvas.scrollHeight;\r\n        this.canvas.width = this.width;                         // set canvas width to the same as the canvas element\r\n        this.canvas.height = this.height;                       // set canvas height to the same as the canvas element\r\n\r\n        this.cellWidth = this.width / this.columns;\r\n        this.cellHeight = this.height / this.rows;\r\n        this.radius = this.cellWidth / 2.6;                     // sets raius for full circle that scales with canvas\r\n        this.radiusSemi = this.cellWidth / 3.6;                 // sets radius for circle outline that scales with canvas\r\n\r\n        //\r\n        this.drawGrid();\r\n    }\r\n\r\n    initialise() {\r\n        // set all cell owners to null\r\n        let rowsArray = [];\r\n        for (let i = 0; i < this.columns; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                rowsArray.push(null);\r\n            }\r\n            this.cellOwners.push(rowsArray);\r\n            rowsArray = [];\r\n        }\r\n\r\n        // size the game\r\n        this.resizeGame();\r\n\r\n    }\r\n\r\n    click(event) {\r\n        // find the next available cell in the column\r\n\r\n        let cell = this.getCell(event.offsetX, event.offsetY);\r\n        // if the cell is full don't do anything\r\n        if (cell[1] == -1) {\r\n            return;\r\n        } else {\r\n            // add cell to player owner\r\n            this.cellOwners[cell[0]][cell[1]] = this.playerTurn;\r\n\r\n            // else draw a new grid with a full circle for the available cell in the column\r\n            this.drawGrid();\r\n\r\n            // toggle player turn\r\n            this.playerTurn ^= 1;\r\n\r\n            // add new circle preview to new available\r\n            cell = this.getCell(event.offsetX, event.offsetY);\r\n            this.drawCell(cell, true);\r\n        }\r\n    }\r\n\r\n    mouseMove(event) {\r\n        // limit mouseMove updates to \r\n        if (Date.now() - this.lastMove > this.updateTime) {\r\n            // find the next available cell in the column\r\n            let cell = this.getCell(event.offsetX, event.offsetY);\r\n\r\n            // if the cell is full don't draw grid without filling cell\r\n            if (cell[1] == -1) {\r\n                this.drawGrid();\r\n            }\r\n            // Else draw a new grid with a semi circle for the available cell in the column\r\n            else {\r\n                this.drawGrid();\r\n                this.drawCell(cell, true);\r\n            }\r\n\r\n            // reset last move\r\n            this.lastMove = Date.now();\r\n        }\r\n    }\r\n\r\n    drawCell(cell, semiCircle = false) {\r\n        let centerX = (cell[0] * this.cellWidth) + (this.cellWidth / 2);\r\n        let centerY = (cell[1] * this.cellHeight) + (this.cellHeight / 2);\r\n\r\n        // get player colour\r\n        if (this.playerTurn == 0) {\r\n            // red player\r\n            this.ctx.fillStyle = this.colourRed;\r\n        } else {\r\n            // yellow player\r\n            this.ctx.fillStyle = this.colourYellow;\r\n        }\r\n\r\n        // draw player colour circle\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(centerX, centerY, this.radius, 0, 2 * Math.PI);\r\n        this.ctx.fill();\r\n\r\n        // if preview circle then blank out center of full circle\r\n        if (semiCircle) {\r\n            this.ctx.fillStyle = this.colourBlank;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(centerX, centerY, this.radiusSemi, 0, 2 * Math.PI);\r\n            this.ctx.fill();\r\n        }\r\n    }\r\n\r\n    // find cell number from x,y position\r\n    checkCell(x, y) {\r\n        if (x == this.width) x--;       // handling edge case\r\n        if (y == this.height) y--;      // handling edge case\r\n        return [Math.trunc(x / this.cellWidth), Math.trunc(y / this.cellHeight)];\r\n    }\r\n\r\n    getCell(x, y) {\r\n        // get cell from mouse click\r\n        let cell = this.checkCell(x, y);\r\n\r\n        // find out which row is the bottom in the column and return that cell\r\n        for (let i = 0; i < this.rows; i++) {\r\n            if (this.cellOwners[cell[0]][i] !== null) {\r\n                return [cell[0], i - 1];\r\n            }\r\n        }\r\n        return [cell[0], this.rows - 1];\r\n    }\r\n\r\n    drawGrid() {\r\n        // create rounded rectange\r\n        this.ctx.fillStyle = this.colourBlue;\r\n        this.roundRect(this.ctx, 0, 0, this.width, this.height, this.radius, true, false)\r\n\r\n        // create grid of holes\r\n        let x = this.cellWidth / 2;                 // sets the initial x center position of the first hole\r\n        let y = this.cellHeight / 2;                // sets the initial y center position of the first hole\r\n        for (let i = 0; i < this.columns; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                if (this.cellOwners[i][j] == 0) {\r\n                    this.ctx.fillStyle = this.colourRed;\r\n                } else if (this.cellOwners[i][j] == 1) {\r\n                    this.ctx.fillStyle = this.colourYellow;\r\n                } else {\r\n                    this.ctx.fillStyle = this.colourBlank;\r\n                }\r\n\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, this.radius, 0, 2 * Math.PI);\r\n                this.ctx.fill();\r\n\r\n                y = y + this.cellHeight;                // increments the x center position for the next hole in the row\r\n            }\r\n            y = this.cellHeight / 2;                    // resets the x center position for the next column of holes\r\n            x = x + this.cellWidth;                     // increments the y center position for the next hole in the column\r\n        }\r\n    }\r\n\r\n\r\n\r\n    roundRect(ctx, x, y, width, height, radius, fill, stroke) {\r\n        if (typeof stroke === 'undefined') {\r\n            stroke = true;\r\n        }\r\n        if (typeof radius === 'undefined') {\r\n            radius = 5;\r\n        }\r\n        if (typeof radius === 'number') {\r\n            radius = { tl: radius, tr: radius, br: radius, bl: radius };\r\n        } else {\r\n            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n            for (var side in defaultRadius) {\r\n                radius[side] = radius[side] || defaultRadius[side];\r\n            }\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + radius.tl, y);\r\n        ctx.lineTo(x + width - radius.tr, y);\r\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\r\n        ctx.lineTo(x + width, y + height - radius.br);\r\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\r\n        ctx.lineTo(x + radius.bl, y + height);\r\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\r\n        ctx.lineTo(x, y + radius.tl);\r\n        ctx.quadraticCurveTo(x, y, x + radius.tl, y);\r\n        ctx.closePath();\r\n        if (fill) {\r\n            ctx.fill();\r\n        }\r\n        if (stroke) {\r\n            ctx.stroke();\r\n        }\r\n\r\n    }\r\n\r\n}","console.log('Kia Ora');\r\n\r\nimport '../css/style.scss';\r\nimport { ConnectFour } from './ConnectFour.js';\r\n\r\n\r\nconst connectFour = new ConnectFour('connect-four');\r\n\r\n"]}