{"version":3,"sources":["js/ConnectFour.js","js/main.js"],"names":["ConnectFour","selector","gameOver","playerTurn","cellOwners","lastMove","updateTime","colourRed","colourYellow","colourBlue","colourBlank","rows","columns","connect","canvas","document","getElementById","width","scrollWidth","height","scrollHeight","cellWidth","cellHeight","radius","radiusSemi","ctx","getContext","initialise","addEventListener","click","bind","mouseMove","rowsArray","i","j","push","drawGrid","event","cell","getCell","offsetX","offsetY","drawCell","Date","now","semiCircle","centerX","centerY","fillStyle","beginPath","arc","Math","PI","fill","x","y","trunc","checkCell","roundRect","stroke","tl","tr","br","bl","defaultRadius","side","moveTo","lineTo","quadraticCurveTo","closePath","console","log","connectFour"],"mappings":"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","file":"main.a6d3c390.js","sourceRoot":"..\\src","sourcesContent":["export class ConnectFour {\r\n    constructor(selector) {\r\n        // Game variables\r\n        this.gameOver = false;\r\n        this.playerTurn = 0;                // player 0 is red, player 1 is yellow\r\n        this.cellOwners = [];               // 2d array. Columns then rows\r\n        this.lastMove = 0;                  // user to keep track of refresh rate\r\n        this.updateTime = 100;              // How often mouseMovement can update in ms\r\n\r\n        // Colours\r\n        this.colourRed = 'rgb(240, 41, 41)';\r\n        this.colourYellow = 'rgb(240, 232, 10)';\r\n        this.colourBlue = 'rgb(44, 173, 242)';\r\n        this.colourBlank = 'rgb(255, 255, 255)';\r\n\r\n        // Drawing variables\r\n        this.rows = 6;\r\n        this.columns = 7;\r\n        this.connect = 4;\r\n\r\n        this.canvas = document.getElementById(selector);\r\n\r\n        this.width = this.canvas.scrollWidth;\r\n        this.height = this.canvas.scrollHeight;\r\n        this.canvas.width = this.width;                         // set canvas width to the same as the canvas element\r\n        this.canvas.height = this.height;                       // set canvas height to the same as the canvas element\r\n\r\n        this.cellWidth = this.width / this.columns;\r\n        this.cellHeight = this.height / this.rows;\r\n        this.radius = this.cellWidth / 2.6;                     // sets raius for full circle that scales with canvas\r\n        this.radiusSemi = this.cellWidth / 3.6;                 // sets radius for circle outline that scales with canvas\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        this.initialise();\r\n\r\n        // Event listeners\r\n        this.canvas.addEventListener('click', this.click.bind(this));\r\n        this.canvas.addEventListener('mousemove', this.mouseMove.bind(this));\r\n    }\r\n\r\n    initialise() {\r\n        // set all cell owners to null\r\n        let rowsArray = [];\r\n        for (let i = 0; i < this.columns; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                rowsArray.push(null);\r\n            }\r\n            this.cellOwners.push(rowsArray);\r\n            rowsArray = [];\r\n        }\r\n\r\n        // draw grid\r\n        this.drawGrid();\r\n    }\r\n\r\n    click(event) {\r\n        // find the next available cell in the column\r\n\r\n        let cell = this.getCell(event.offsetX, event.offsetY);\r\n        // if the cell is full don't do anything\r\n        if (cell[1] == -1) {\r\n            return;\r\n        } else {\r\n            // add cell to player owner\r\n            this.cellOwners[cell[0]][cell[1]] = this.playerTurn;\r\n\r\n            // else draw a new grid with a full circle for the available cell in the column\r\n            this.drawGrid();\r\n\r\n            // toggle player turn\r\n            this.playerTurn ^= 1;\r\n\r\n            // add new circle preview to new available\r\n            cell = this.getCell(event.offsetX, event.offsetY);\r\n            this.drawCell(cell, true);\r\n        }\r\n    }\r\n\r\n    mouseMove(event) {\r\n        // limit mouseMove updates to \r\n        if (Date.now() - this.lastMove > this.updateTime) {\r\n            // find the next available cell in the column\r\n            let cell = this.getCell(event.offsetX, event.offsetY);\r\n\r\n            // if the cell is full don't draw grid without filling cell\r\n            if (cell[1] == -1) {\r\n                this.drawGrid();\r\n            }\r\n            // Else draw a new grid with a semi circle for the available cell in the column\r\n            else {\r\n                this.drawGrid();\r\n                this.drawCell(cell, true);\r\n            }\r\n\r\n            // reset last move\r\n            this.lastMove = Date.now();\r\n        }\r\n    }\r\n\r\n    drawCell(cell, semiCircle = false) {\r\n        let centerX = (cell[0] * this.cellWidth) + (this.cellWidth / 2);\r\n        let centerY = (cell[1] * this.cellHeight) + (this.cellHeight / 2);\r\n\r\n        // get player colour\r\n        if (this.playerTurn == 0) {\r\n            // red player\r\n            this.ctx.fillStyle = this.colourRed;\r\n        } else {\r\n            // yellow player\r\n            this.ctx.fillStyle = this.colourYellow;\r\n        }\r\n\r\n        // draw player colour circle\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(centerX, centerY, this.radius, 0, 2 * Math.PI);\r\n        this.ctx.fill();\r\n\r\n        // if preview circle then blank out center of full circle\r\n        if (semiCircle) {\r\n            this.ctx.fillStyle = this.colourBlank;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(centerX, centerY, this.radiusSemi, 0, 2 * Math.PI);\r\n            this.ctx.fill();\r\n        }\r\n    }\r\n\r\n    checkCell(x, y) {\r\n        return [Math.trunc(x / this.cellWidth), Math.trunc(y / this.cellHeight)];\r\n    }\r\n\r\n    getCell(x, y) {\r\n        // get cell from mouse click\r\n        let cell = this.checkCell(x, y);\r\n\r\n        // find out which row is the bottom in the column and return that cell\r\n        for (let i = 0; i < this.rows; i++) {\r\n            if (this.cellOwners[cell[0]][i] !== null) {\r\n                return [cell[0], i - 1];\r\n            }\r\n        }\r\n        return [cell[0], this.rows - 1];\r\n    }\r\n\r\n\r\n    drawGrid() {\r\n        // create rounded rectange\r\n        this.ctx.fillStyle = this.colourBlue;\r\n        this.roundRect(this.ctx, 0, 0, this.width, this.height, 20, true, false)\r\n\r\n        // create grid of holes\r\n        let x = this.cellWidth / 2;                 // sets the initial x center position of the first hole\r\n        let y = this.cellHeight / 2;                // sets the initial y center position of the first hole\r\n        for (let i = 0; i < this.columns; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                if (this.cellOwners[i][j] == 0) {\r\n                    this.ctx.fillStyle = this.colourRed;\r\n                } else if (this.cellOwners[i][j] == 1) {\r\n                    this.ctx.fillStyle = this.colourYellow;\r\n                } else {\r\n                    this.ctx.fillStyle = this.colourBlank;\r\n                }\r\n\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, this.radius, 0, 2 * Math.PI);\r\n                this.ctx.fill();\r\n\r\n                y = y + this.cellHeight;                // increments the x center position for the next hole in the row\r\n            }\r\n            y = this.cellHeight / 2;                    // resets the x center position for the next column of holes\r\n            x = x + this.cellWidth;                     // increments the y center position for the next hole in the column\r\n        }\r\n    }\r\n\r\n    roundRect(ctx, x, y, width, height, radius, fill, stroke) {\r\n        if (typeof stroke === 'undefined') {\r\n            stroke = true;\r\n        }\r\n        if (typeof radius === 'undefined') {\r\n            radius = 5;\r\n        }\r\n        if (typeof radius === 'number') {\r\n            radius = { tl: radius, tr: radius, br: radius, bl: radius };\r\n        } else {\r\n            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n            for (var side in defaultRadius) {\r\n                radius[side] = radius[side] || defaultRadius[side];\r\n            }\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + radius.tl, y);\r\n        ctx.lineTo(x + width - radius.tr, y);\r\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\r\n        ctx.lineTo(x + width, y + height - radius.br);\r\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\r\n        ctx.lineTo(x + radius.bl, y + height);\r\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\r\n        ctx.lineTo(x, y + radius.tl);\r\n        ctx.quadraticCurveTo(x, y, x + radius.tl, y);\r\n        ctx.closePath();\r\n        if (fill) {\r\n            ctx.fill();\r\n        }\r\n        if (stroke) {\r\n            ctx.stroke();\r\n        }\r\n\r\n    }\r\n\r\n}","console.log('Kia Ora');\r\n\r\nimport '../css/style.scss';\r\nimport { ConnectFour } from './ConnectFour.js';\r\n\r\n\r\nconst connectFour = new ConnectFour('connect-four');\r\n\r\n"]}